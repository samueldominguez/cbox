;;; cbox.el --- inserting block commands for explaining big chunks of code

;; Copyright © 2017 Samuel Domínguez Lorenzo

;; Filename: cbox.el
;; Maintainer: samueldominguez@protonmail.com
;; Keywords: comment, box

;; Created: 05 Jan 2017
;; URL: https://github.com/samueldominguez/cbox

;;
;; Example configuration: (~/.emacs config):
;;
;; 1. Make sure cbox.el somewhere in your load
;;    path, it will load automatically like any
;;    other .el file in your load path.
;;
;; 2. Use autoload (or any other method) to make
;;    cbox visible:
;;    (autoload 'cbox-trigger "cbox" "Comment blocks editing" t)
;;
;; 3. Map cbox-trigger to your prefered
;;    keybinding e.g. :
;;    (global-set-key (kbd "C-c /") 'cbox-trigger)
;;
;; Usage:
;;
;; Invoke cbox-trigger, to start typing your
;; comment block and type C-c C-c to insert
;; the text into the original buffer at the
;; relative point (marker) in which you left.
;;
;; You can type C-c C-k to cancel.
;;

;; This program is free software; you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation; either version 3, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful, but WITHOUT
;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
;; more details.
;;
;; You should have received a copy of the GNU General Public License along
;; with this program; see the file COPYING.  If not, write to the Free
;; Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
;; 02110-1301, USA.

;; cbox operation:
;;
;; NOTE: you can do the following on top of a comment generated by cbox
;; and cbox will open that comment up in the buffer to edit.
;;
;; Steps:
;; 1.  User types keybinding mapped to cbox-trigger / invokes cbox-trigger
;; 2.  We save current position via marker
;; 3.  Split window vertically
;; 4.  Open temporary buffer
;; 5.  Major mode is set to fundamental and we set auto-fill minor mode
;; 6.  User types the comment text
;; 7.  User types C-c C-c / invokes cbox-trigger or C-c C-k and goto step 10
;; 8.  Parse all text in buffer to add necessary characters to box it in comments
;; 9.  Copy it to previously stored marker in original buffer
;; 10. Kill temporary buffer
;; 11. Kill window which held temporary buffer
;; 12. Go back to the buffer which invoked cbox-trigger originally
;; 13. Set mark to the next line of the last comment box line

;;    Default boxing style:

;; /*==================================*
;;  | This box has text from top to    |
;;  | bottom, so no empty lines at the |
;;  | top and bottom, and one space    |
;;  | at the start of each line        |
;;  *==================================*/

;;; Code:

(defconst cbox-comment-buffer-name " cbox edit "
  "Name given to the buffer used to write the comments")

(defvar cbox-insert-marker nil
  "Contains the point at which we will later insert the inputted comments")

(defvar cbox-comment-buffer nil
  "Contains the buffer used to write the comments")

(defvar cbox-source-buffer nil
  "Contains the buffer where cbox was called from")

(defvar cbox-comment-buffer-lines nil
  "Contains all the text lines in a list which make up cbox-comment-buffer,
this is created when the user finishes typing their comment and re-invoke
cbox-trigger")

(defvar cbox-comment-buffer-max-line-length nil
  "Contains the number of characters of the longest line in cbox-comment-buffer")

(defvar cbox-return-marker nil
  "Contains the marker to return to when we are done with everything")

(defvar cbox-editing-existing nil
  "Determines whether we are modifying an existing comment or if we
are creating a new comment")

(defvar cbox-original-comment nil
  "If editing an existing comment, this holds the original copy which will be
further proceesed to place in the temporary buffer and in case the user aborts
the operation we can put back exactly what we got in the first place")

(defvar cbox-original-comment-points nil
  "If editing an existing comment this holds the character counts that mark the are
the original comment is defined in")

(defvar cbox-original-text nil
  "Holds the processed text inside cbox-original-text")

;; cbox-token-config should have the following format:
;; (starting-token ending-token top-token corner-token side-token inner-box-margin text-margin)

;; starting-token: the token that starts a comment, for example /* in C
;; ending-token: the token that ends a comment, for example */ in C, if using
;;               single line comments for the making of a box, this would be the
;;               same as the starting token, so in the case of C++ you could
;;               have // as starting-token and // as ending-token
;; top-token: the token used for filling the top side and bottom side
;;            of the box, for example a * or a =
;; side-token: the token used for filling both sides of the box, this could
;;             be anything, like a | or a *
;; corner-token: the token used to fill top right and bottom left corners of the box,
;;               for example in C, this is a * but for mono-character boxes you can use
;;               the character that you used for top-token for example
;; inner-box-margin: this is used to determine the offset of the sides of the
;;                   box, for example when you have this box in C:
;;
;; /*==================================*
;;  | This box has text from top to    |
;;  | bottom, so no empty lines at the |
;;  | top and bottom, and one space    |
;;  | at the start of each line        |
;;  *==================================*/
;; 
;; NOTE all of the lines are shifted but the first!
;;
;; The starting token is composed of two characters, that shifts the box to
;; the right by one character, for comparison here is what it would look like
;; if we were using a one character starting token:
;;
;; ###########################
;; # Hello this is a comment #
;; # inside a beautiful box! #
;; ###########################
;;
;; The side is not shifted. In the first example, inner-box-margin would be 1,
;; in this one, it would be 0
;;
;; text-margin: this is used to determine the margin of the text from the box
;;              on the sides, so as an example first a 0 text-margin box will
;;              be shown and then a 1 text-margin box will be shown
;; 
;; #########################
;; #Hello this is a comment#
;; #inside a beautiful box!#
;; #########################
;;
;; ###########################
;; # Hello this is a comment #
;; # inside a beautiful box! #
;; ###########################
;; 
;; mono: this is used to determine if the box uses the same character all over
;;       or if it uses different ones. C like boxing is nil, others like Lisp
;;       are t for example
;; 

(defvar cbox-token-config nil
  "Holds the tokens to use for box making")

;; Token lists for different major-modes, adjust to liking or modify externally

;; Emacs Lisp
(defvar cbox-emacs-lisp-mode (list :starting-token ";;" :ending-token ";;" :top-token ";" :corner-token ";;" :side-token ";;" :inner-box-margin 0 :text-margin 1 :mono t))
;; C / C++ / Java / C#
(defvar cbox-c-mode (list :starting-token "/*" :ending-token "*/" :top-token "=" :corner-token "*" :side-token "|" :inner-box-margin 1 :text-margin 1 :mono nil))
;; R
(defvar cbox-r-mode (list :starting-token "#" :ending-token "#" :top-token "#" :corner-token "#" :side-token "#" :inner-box-margin 0 :text-margin 1 :mono t))

(setq cbox-insert-marker (make-marker))
(setq cbox-return-marker (make-marker))

(defun cbox-trigger ()
  "Main function of cbox, it opens a buffer in text mode with auto-fill minor mode in a vertically
split window, allowing the user to type a comment and later when re-invoked insert the text in comment
form in the original buffer where cbox-trigger was initially invoked."
  (interactive)
  (if (eq (buffer-live-p cbox-comment-buffer) nil)
      (progn
	(cbox-set-token-config)
	(set-marker cbox-insert-marker (point))
	(if (cbox-is-on-comment)
	    (progn
	      (setq cbox-editing-existing t)
	      (if (getf cbox-token-config :mono)
		  (cbox-extract-comment-mono)
		(cbox-extract-comment))
		(cbox-extract-text))
	  (setq cbox-editing-existing nil))
	(setq cbox-source-buffer (current-buffer))
	(split-window-right)
	(other-window 1)
	(setq cbox-comment-buffer (generate-new-buffer cbox-comment-buffer-name))
	(switch-to-buffer cbox-comment-buffer)
	(auto-fill-mode)
	(local-set-key "\C-c\C-c" 'cbox-trigger)
	(local-set-key "\C-c\C-k" 'cbox-abort)
	(when cbox-editing-existing
	    (cbox-insert-original-text)))
    (progn
      (setq cbox-comment-buffer-lines (split-string (buffer-string) "\n"))
      (setq cbox-comment-buffer-max-line-length (cbox-determine-max-line))
      (switch-to-buffer cbox-source-buffer)
      (when cbox-editing-existing
	(cbox-delete-original-comment))
      (cbox-insert-comment)
      (kill-buffer cbox-comment-buffer)
      (delete-window)
      (goto-char cbox-return-marker)
      (forward-line 1))))

(defun cbox-abort ()
  "Invoked by C-c C-k, buffer local. Aborts inserting comment block."
  (interactive)
  (kill-buffer cbox-comment-buffer)
  (delete-window))

(defun cbox-determine-max-line ()
  "Sets cbox-comment-buffer-max-line-length to the longest line in cbox-comment-buffer"
  (let ((max 0))
    (dolist (el cbox-comment-buffer-lines max)
      (when (> (length el) max)
	(setq max (length el))))))

(defun cbox-insert-comment ()
  "Puts the cbox edit buffer contents into the original source buffer in the
comment format corresponding with token-config"
  (unless cbox-editing-existing
    (goto-char cbox-insert-marker))
  (let ((top-left (getf cbox-token-config :starting-token)) (top-right (getf cbox-token-config :corner-token)) (lower-left (getf cbox-token-config :corner-token)) (lower-right (getf cbox-token-config :ending-token)) (top-bot (string-to-char (getf cbox-token-config :top-token))) (side (getf cbox-token-config :side-token)) (maxlength cbox-comment-buffer-max-line-length) (txtmargin (getf cbox-token-config :text-margin)) (boxmargin (getf cbox-token-config :inner-box-margin)))
    ;; top line
    (insert (concat top-left (make-string (+ maxlength (* txtmargin 2)) top-bot) top-right "\n"))
    ;;intermediate lines
    (dolist (line cbox-comment-buffer-lines)
      (progn
	(when (eq line "") (setq line "\n"))
	(insert (concat (make-string boxmargin ? ) side (make-string txtmargin ? ) line (make-string (- maxlength (length line)) ? ) (make-string txtmargin ? ) side "\n"))))
    ;; bottom line
    (insert (concat (make-string boxmargin ? ) lower-left (make-string (+ maxlength (* txtmargin 2)) top-bot) lower-right)))
  (set-marker cbox-return-marker (point))
  (switch-to-buffer cbox-comment-buffer))

(defun cbox-is-on-comment ()
  "Returns t if we are in a comment or nil if we are not. If we are
we set the cbox-edit-comment to the positions of start/finish so we can
later extract the text and redo the comment"
  (or (nth 4 (syntax-ppss))
      (memq (get-text-property (point) 'face)
	    '(font-lock-comment-face font-lock-comment-delimiter-face))))

;; This works only for configurations where the starting token, side token and ending
;; token are all different from each other, like in C for example (see the C token config)
(defun cbox-extract-comment ()
  "Scans area around point to copy the entire comment that the point is on,
it stores it in cbox-original-comment"
  (let (line (start -1) (end -1))
    (loop do
	  (setq line (thing-at-point 'line t))
	  (when (string-match-p (regexp-quote (getf cbox-token-config :starting-token)) line)
	    (progn
	      (beginning-of-line)
	      (setq start (point))
	      (return)))
	  while (= 0 (forward-line -1)))
    (goto-char cbox-insert-marker)
    (loop do
	  (setq line (thing-at-point 'line t))
	  (when (string-match-p (regexp-quote (getf cbox-token-config :ending-token)) line)
	    (progn
	      (end-of-line)
	      (setq end (point))
	      (return)))
	  while (= 0 (forward-line 1)))
    (goto-char cbox-insert-marker)
    (setq cbox-original-comment (buffer-substring-no-properties start end))
    (setq cbox-original-comment-points (list start end))))

(defun cbox-extract-comment-mono ()
  "Does the same as cbox-extract-comment but for comment types where all (or most?)
of the characters comprising the box are the same character (e.g. lisp comments)"
  (let (line (start -1) (end -1))
    (loop do
	  (setq line (thing-at-point 'line t))
	  (unless (cbox-is-on-comment)
	    (progn
	      (forward-line 1)
	      (beginning-of-line)
	      (setq start (point))
	      (return)))
	  while (= 0 (forward-line -1)))
    (goto-char cbox-insert-marker)
    (loop do
	  (setq line (thing-at-point 'line t))
	  (unless (cbox-is-on-comment)
	    (progn
	      (forward-line -1)
	      (end-of-line)
	      (setq end (point))
	      (return)))
	  while (= 0 (forward-line 1)))
    (goto-char cbox-insert-marker)
    (setq cbox-original-comment (buffer-substring-no-properties start end))
    (setq cbox-original-comment-points (list start end))))

(defun cbox-extract-text ()
  "Discards comment delimiter tokens and boxing tokens"
  (setq cbox-original-text "")
  (let ((lines (split-string cbox-original-comment "\n")) (left-discard (+ (getf cbox-token-config :inner-box-margin) (length (getf cbox-token-config :side-token)) (getf cbox-token-config :text-margin)))
	(right-discard (+ (getf cbox-token-config :text-margin) (length (getf cbox-token-config :side-token)))))
    (setq lines (butlast (rest lines)))     ;; top and bottom lines get eliminated
    (loop for line in lines for i from 0 do
	  (setq cbox-original-text
	    (concat cbox-original-text (string-trim-right (apply (function string) (butlast (nthcdr left-discard (string-to-list line)) right-discard))) (if (= (- (length lines) 1) i) "" "\n"))))))

(defun cbox-insert-original-text ()
  "Inserts cbox-original-text into the newly created temporary buffer"
  (insert cbox-original-text))

(defun cbox-delete-original-comment ()
  "Deletes the original comment that was edited"
  (goto-char (first cbox-original-comment-points))
  (delete-char (- (second cbox-original-comment-points) (first cbox-original-comment-points))))

(defun cbox-set-token-config ()
  "Sets cbox-token-config depending on major-mode"
  major-mode
  (if (eq major-mode 'emacs-lisp-mode)
      (setq cbox-token-config cbox-emacs-lisp-mode)
    (if (eq major-mode 'ess-mode)
	(setq cbox-token-config cbox-r-mode)
      ;; else just put c-mode as default
      (setq cbox-token-config cbox-c-mode))))

;;; cbox.el ends here
